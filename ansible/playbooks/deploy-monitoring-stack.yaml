---
# Run preflight checks before deploying monitoring
- import_playbook: preflight-monitoring.yaml
# =============================================================================
# =============================================================================
# VMStation Monitoring Stack Deployment
# =============================================================================
# Deploy complete monitoring stack using Kustomize
#
# Usage:
#   ansible-playbook -i /srv/vmstation-org/cluster-setup/ansible/inventory/hosts.yml playbooks/deploy-monitoring-stack.yaml
#
# =============================================================================

- name: "Deploy VMStation Enterprise Monitoring Stack"
  hosts: monitoring_nodes
  gather_facts: true
  become: true
  vars:
    manifests_dir: "{{ playbook_dir }}/../../manifests"
    kubeconfig: "/etc/kubernetes/admin.conf"
  
  tasks:
    - name: "Display deployment banner"
      ansible.builtin.debug:
        msg: |
          ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
          VMStation Monitoring Stack Deployment
          ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
          Components:
          - Prometheus (metrics time-series database)
          - Grafana (dashboards and visualization)
          - Loki (log aggregation)
          - Promtail (log shipper)
          - Kube-state-metrics (K8s object metrics)
          - Node-exporter (system metrics)
          - Blackbox-exporter (probes)
          - IPMI-exporter (hardware monitoring)
          ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

    # =============================================================================
    # Pre-deployment Validation
    # =============================================================================
    
    - name: "Verify Kubernetes cluster is accessible"
      ansible.builtin.command:
        cmd: kubectl --kubeconfig={{ kubeconfig }} cluster-info
      register: cluster_info
      changed_when: false
      failed_when: cluster_info.rc != 0

    - name: "Display cluster information"
      ansible.builtin.debug:
        msg: "{{ cluster_info.stdout_lines }}"

    - name: "Check node resources"
      ansible.builtin.shell: |
        set -o pipefail
        echo "Total Memory: $(free -h | grep Mem | awk '{print $2}')"
        echo "Available Memory: $(free -h | grep Mem | awk '{print $7}')"
        echo "CPU Cores: $(nproc)"
      args:
        executable: /bin/bash
      register: node_resources
      changed_when: false

    - name: "Display node resources"
      ansible.builtin.debug:
        msg: "{{ node_resources.stdout_lines }}"

    # =============================================================================
    # Create Storage Directories
    # =============================================================================
    
    - name: "Create monitoring data directories with proper permissions"
      ansible.builtin.file:
        path: "{{ item.path }}"
        state: directory
        mode: '0755'
        owner: "{{ item.owner | default('root') }}"
        group: "{{ item.group | default('root') }}"
      loop:
        - { path: '/srv/monitoring_data' }
        - { path: '/srv/monitoring_data/grafana', owner: '472', group: '472' }
        - { path: '/srv/monitoring_data/prometheus', owner: '65534', group: '65534' }
        - { path: '/srv/monitoring_data/loki', owner: '10001', group: '10001' }
        - { path: '/srv/monitoring_data/promtail', owner: '0', group: '0' }

    # Ensure NFS export has appropriate options and fix ownership on NFS server
    - name: "Ensure monitoring export uses no_root_squash and remove anonuid/anongid"
      ansible.builtin.lineinfile:
        path: /etc/exports
        regexp: '^/srv/monitoring_data\s'
        line: '/srv/monitoring_data 192.168.4.0/24(rw,sync,no_subtree_check,no_root_squash)'
        create: yes
      delegate_to: storagenodet3500
      run_once: true

    - name: "Reload NFS export table on storagenodet3500"
      ansible.builtin.command:
        cmd: exportfs -ra
      delegate_to: storagenodet3500
      run_once: true

    - name: "Ensure ownership and permissions of monitoring_data directories on NFS server"
      ansible.builtin.file:
        path: "{{ item.path }}"
        owner: "{{ item.owner }}"
        group: "{{ item.group }}"
        mode: "{{ item.mode }}"
        recurse: yes
      loop:
        - { path: '/srv/monitoring_data/grafana', owner: '472', group: '472', mode: '0755' }
        - { path: '/srv/monitoring_data/loki', owner: '10001', group: '10001', mode: '0755' }
        - { path: '/srv/monitoring_data/prometheus', owner: '65534', group: '65534', mode: '0755' }
      delegate_to: storagenodet3500
      run_once: true

    # Apply static PVCs (bind pv-prometheus/pv-loki)
    - name: "Apply PVC bindings for prometheus and loki"
      ansible.builtin.command:
        cmd: kubectl --kubeconfig={{ kubeconfig }} apply -f {{ manifests_dir }}/pvc-bindings.yaml
      register: pvc_bind_apply
      changed_when: "'created' in pvc_bind_apply.stdout or 'configured' in pvc_bind_apply.stdout"

    - name: "Display PVC apply result"
      ansible.builtin.debug:
        msg: "{{ pvc_bind_apply.stdout_lines }}"

    # Create Grafana OAuth secret if vars are provided (safe: only when both vars set)

    - name: "Register Grafana client in Keycloak when admin credentials available"
      block:
        - name: "Get Keycloak admin token"
          ansible.builtin.uri:
            url: "{{ (keycloak_url | default(keycloak_admin_url | default('http://' + ansible_default_ipv4.address + ':30180'))) }}/auth/realms/master/protocol/openid-connect/token"
            method: POST
            body: "client_id=admin-cli&username={{ keycloak_admin_user }}&password={{ keycloak_admin_password }}&grant_type=password"
            headers:
              Content-Type: "application/x-www-form-urlencoded"
            return_content: yes
            status_code: 200
          register: keycloak_token

        - name: "Set Keycloak access token fact"
          ansible.builtin.set_fact:
            keycloak_access_token: "{{ keycloak_token.json.access_token }}"

        - name: "Check for existing Grafana client in Keycloak"
          ansible.builtin.uri:
            url: "{{ (keycloak_url | default(keycloak_admin_url | default('http://' + ansible_default_ipv4.address + ':30180'))) }}/auth/admin/realms/{{ grafana_oauth_realm | default('cluster-services') }}/clients?clientId={{ grafana_oauth_client_name | default('grafana') }}"
            method: GET
            headers:
              Authorization: "Bearer {{ keycloak_access_token }}"
            return_content: yes
            status_code: 200
          register: keycloak_client_check

        - name: "Create Grafana client in Keycloak if missing"
          ansible.builtin.uri:
            url: "{{ (keycloak_url | default(keycloak_admin_url | default('http://' + ansible_default_ipv4.address + ':30180'))) }}/auth/admin/realms/{{ grafana_oauth_realm | default('cluster-services') }}/clients"
            method: POST
            headers:
              Authorization: "Bearer {{ keycloak_access_token }}"
            body_format: json
            body:
              clientId: "{{ grafana_oauth_client_name | default('grafana') }}"
              name: "{{ grafana_oauth_client_name | default('grafana') }}"
              enabled: true
              publicClient: false
              serviceAccountsEnabled: true
              redirectUris:
                - "{{ grafana_oauth_redirect_uri | default('http://' + ansible_default_ipv4.address + ':30300/login/generic_oauth') }}"
            status_code: [201,409]
          when: keycloak_client_check.json | length == 0
          register: keycloak_client_create

        - name: "Get Grafana client internal id"
          ansible.builtin.uri:
            url: "{{ (keycloak_url | default(keycloak_admin_url | default('http://' + ansible_default_ipv4.address + ':30180'))) }}/auth/admin/realms/{{ grafana_oauth_realm | default('cluster-services') }}/clients?clientId={{ grafana_oauth_client_name | default('grafana') }}"
            method: GET
            headers:
              Authorization: "Bearer {{ keycloak_access_token }}"
            return_content: yes
            status_code: 200
          register: keycloak_client_info

        - name: "Set Grafana client id/secret facts from Keycloak"
          ansible.builtin.set_fact:
            grafana_oauth_client_internal_id: "{{ keycloak_client_info.json[0].id }}"

        - name: "Update Grafana client with correct redirect URIs for native OAuth"
          ansible.builtin.uri:
            url: "{{ (keycloak_url | default(keycloak_admin_url | default('http://' + ansible_default_ipv4.address + ':30180'))) }}/auth/admin/realms/{{ grafana_oauth_realm | default('cluster-services') }}/clients/{{ grafana_oauth_client_internal_id }}"
            method: PUT
            headers:
              Authorization: "Bearer {{ keycloak_access_token }}"
              Content-Type: "application/json"
            body_format: json
            body:
              clientId: "{{ grafana_oauth_client_name | default('grafana') }}"
              name: "{{ grafana_oauth_client_name | default('grafana') }}"
              enabled: true
              publicClient: false
              serviceAccountsEnabled: true
              baseUrl: "http://{{ ansible_default_ipv4.address }}:30300"
              redirectUris:
                - "http://{{ ansible_default_ipv4.address }}:30300/*"
                - "http://{{ ansible_default_ipv4.address }}:30300/login/generic_oauth"
              webOrigins:
                - "+"
            status_code: [204]
          register: keycloak_client_update

        - name: "Generate client secret for Grafana client"
          ansible.builtin.uri:
            url: "{{ (keycloak_url | default(keycloak_admin_url | default('http://' + ansible_default_ipv4.address + ':30180'))) }}/auth/admin/realms/{{ grafana_oauth_realm | default('cluster-services') }}/clients/{{ grafana_oauth_client_internal_id }}/client-secret"
            method: POST
            headers:
              Authorization: "Bearer {{ keycloak_access_token }}"
              Content-Type: "application/json"
            return_content: yes
            status_code: 200
          register: keycloak_client_secret

        - name: "Set Grafana OAuth client credentials facts"
          ansible.builtin.set_fact:
            grafana_oauth_client_id: "{{ grafana_oauth_client_name | default('grafana') }}"
            grafana_oauth_client_secret: "{{ keycloak_client_secret.json.value }}"
      when: grafana_oauth_client_id is not defined and keycloak_admin_user is defined and keycloak_admin_password is defined and (keycloak_url is defined or keycloak_admin_url is defined)
      run_once: true

    - name: "Derive Grafana Keycloak OIDC endpoints from keycloak_url"
      ansible.builtin.set_fact:
        grafana_oauth_auth_url: "{{ keycloak_url | default(keycloak_admin_url) ~ '/auth/realms/' ~ (grafana_oauth_realm | default('cluster-services')) ~ '/protocol/openid-connect/auth' }}"
        grafana_oauth_token_url: "{{ keycloak_url | default(keycloak_admin_url) ~ '/auth/realms/' ~ (grafana_oauth_realm | default('cluster-services')) ~ '/protocol/openid-connect/token' }}"
        grafana_oauth_api_url: "{{ keycloak_url | default(keycloak_admin_url) ~ '/auth/realms/' ~ (grafana_oauth_realm | default('cluster-services')) ~ '/protocol/openid-connect/userinfo' }}"
      when: (keycloak_url is defined or keycloak_admin_url is defined)
      run_once: true

    - name: "Create Grafana OAuth secret in cluster using generated or provided credentials"
      become: true
      become_user: root
      ansible.builtin.shell: |
        kubectl --kubeconfig={{ kubeconfig }} -n monitoring create secret generic grafana-oauth \
          --from-literal=client-id='{{ grafana_oauth_client_id }}' \
          --from-literal=client-secret='{{ grafana_oauth_client_secret }}' \
          --dry-run=client -o yaml | kubectl --kubeconfig={{ kubeconfig }} apply -f -
      when: grafana_oauth_client_id is defined and grafana_oauth_client_secret is defined
      register: grafana_oauth_secret
      changed_when: "grafana_oauth_secret.rc == 0"


    - name: "Display grafana oauth secret apply result"
      ansible.builtin.debug:
        msg: "{{ grafana_oauth_secret.stdout_lines | default([]) }}"

    - name: "Display grafana oauth secret apply result"
      ansible.builtin.debug:
        msg: "{{ grafana_oauth_secret.stdout_lines | default([]) }}"

    # NOTE: OAuth configuration moved to AFTER deployment (line ~439)
    # Configuring the deployment here fails because Grafana doesn't exist yet
    #
    # - name: "Configure Grafana deployment for Keycloak OAuth when parameters provided"
    #   become: true
    #   become_user: root
    #   ansible.builtin.command:
    #     cmd: >
    #       kubectl --kubeconfig={{ kubeconfig }} -n monitoring set env deployment/grafana
    #       GF_AUTH_GENERIC_OAUTH_ENABLED=true
    #       GF_AUTH_GENERIC_OAUTH_NAME=Keycloak
    #       GF_AUTH_GENERIC_OAUTH_ALLOW_SIGN_UP=true
    #       GF_AUTH_GENERIC_OAUTH_SCOPES='openid profile email'
    #       GF_AUTH_GENERIC_OAUTH_AUTH_URL='{{ grafana_oauth_auth_url | default(omit) }}'
    #       GF_AUTH_GENERIC_OAUTH_TOKEN_URL='{{ grafana_oauth_token_url | default(omit) }}'
    #       GF_AUTH_GENERIC_OAUTH_API_URL='{{ grafana_oauth_api_url | default(omit) }}'
    #   when: grafana_oauth_client_id is defined and grafana_oauth_client_secret is defined and (grafana_oauth_auth_url is defined and grafana_oauth_token_url is defined and grafana_oauth_api_url is defined)
    #   register: grafana_oauth_env
    #   changed_when: true
    #
    # - name: "Display grafana deployment env patch result"
    #   ansible.builtin.debug:
    #     msg: "{{ grafana_oauth_env.stdout_lines | default([]) }}"

    # =============================================================================
    # Deploy Monitoring Stack using Kustomize
    # =============================================================================
    
    - name: "Deploy monitoring stack using Kustomize"
      block:
        - name: "Apply monitoring kustomize"
          become: true
          become_user: root
          ansible.builtin.command:
            cmd: kubectl --kubeconfig={{ kubeconfig }} apply -k {{ manifests_dir }}
          register: deploy_result
          failed_when: deploy_result.rc != 0
      rescue:
        - name: "Detect immutable StatefulSet spec error and attempt safe recreate"
          ansible.builtin.debug:
            msg: "Immutable StatefulSet spec error detected, recreating affected StatefulSets (prometheus,loki)"

        - name: "Scale down and delete affected StatefulSets to allow spec update"
          ansible.builtin.shell: |
            set -e
            for sts in prometheus loki; do
              if kubectl --kubeconfig={{ kubeconfig }} -n monitoring get sts $sts >/dev/null 2>&1; then
                kubectl --kubeconfig={{ kubeconfig }} -n monitoring scale sts $sts --replicas=0 || true
                kubectl --kubeconfig={{ kubeconfig }} -n monitoring delete sts $sts --ignore-not-found || true
              fi
            done
          register: sts_cleanup
          changed_when: sts_cleanup.rc == 0

        - name: "Reapply monitoring kustomize after recreating statefulsets"
          become: true
          become_user: root
          ansible.builtin.command:
            cmd: kubectl --kubeconfig={{ kubeconfig }} apply -k {{ manifests_dir }}
          register: deploy_result_after
          failed_when: deploy_result_after.rc != 0

        - name: "Set deploy_result to reapply output"
          ansible.builtin.set_fact:
            deploy_result: "{{ deploy_result_after }}"

    - name: "Display deployment result"
      ansible.builtin.debug:
        msg: "{{ deploy_result.stdout_lines }}"

      # Ensure Grafana provisioning configmaps (datasources + dashboards) are applied first
    - name: "Apply Grafana provisioning ConfigMaps (datasources + dashboards)"
      become: true
      become_user: root
      ansible.builtin.command:
        cmd: kubectl --kubeconfig={{ kubeconfig }} apply -f {{ manifests_dir }}/grafana/configmap.yaml -n monitoring
      register: grafana_cfg_apply
      changed_when: "'created' in grafana_cfg_apply.stdout or 'configured' in grafana_cfg_apply.stdout"

    - name: "Apply Grafana dashboards ConfigMap"
      become: true
      become_user: root
      ansible.builtin.command:
        cmd: kubectl --kubeconfig={{ kubeconfig }} apply -f {{ manifests_dir }}/grafana/dashboards-configmap.yaml -n monitoring
      register: grafana_dash_apply
      changed_when: "'created' in grafana_dash_apply.stdout or 'configured' in grafana_dash_apply.stdout"

    - name: "Display grafana config apply results"
      ansible.builtin.debug:
        msg: "cfg: {{ grafana_cfg_apply.stdout_lines | default([]) }}; dashboards: {{ grafana_dash_apply.stdout_lines | default([]) }}"

    - name: "Restart grafana to pick up new provisioning config"
      become: true
      become_user: root
      ansible.builtin.command:
        cmd: kubectl --kubeconfig={{ kubeconfig }} -n monitoring rollout restart deployment/grafana
      register: grafana_restart
      changed_when: true

    - name: "Wait for grafana to be ready (120s)"
      ansible.builtin.command:
        cmd: kubectl --kubeconfig={{ kubeconfig }} wait --for=condition=available deployment/grafana -n monitoring --timeout=120s
      register: grafana_ready_post
      failed_when: false
      changed_when: false

    # DISABLED: oauth2-proxy adds unnecessary complexity - Grafana has native OAuth support
    # - name: "Ensure oauth2-proxy for Grafana: create k8s secret with client creds and cookie"
    #   become: true
    #   become_user: root
    #   ansible.builtin.shell: |
    #     set -e
    #     # Generate cookie secret: base64(24 bytes) = exactly 32 characters (32 bytes for AES cipher)
    #     COOKIE_SECRET=$(openssl rand -base64 24)
    #     kubectl --kubeconfig={{ kubeconfig }} -n monitoring create secret generic oauth2-proxy-grafana \
    #       --from-literal=client-id='{{ grafana_oauth_client_id | default(omit) }}' \
    #       --from-literal=client-secret='{{ grafana_oauth_client_secret | default(omit) }}' \
    #       --from-literal=cookie-secret="$COOKIE_SECRET" \
    #       --dry-run=client -o yaml | kubectl --kubeconfig={{ kubeconfig }} apply -f -
    #   when: grafana_oauth_client_id is defined and grafana_oauth_client_secret is defined
    #   register: oauth2_secret_apply
    #   changed_when: "oauth2_secret_apply.rc == 0"
    #
    # - name: "Deploy oauth2-proxy for Grafana (Deployment + Service)"
    #   become: true
    #   become_user: root
    #   ansible.builtin.shell: |
    #     set -e
    #     cat <<'EOF' | kubectl --kubeconfig={{ kubeconfig }} -n monitoring apply -f -
    #     apiVersion: apps/v1
    #     kind: Deployment
    #     metadata:
    #       name: oauth2-proxy-grafana
    #       labels:
    #         app: oauth2-proxy-grafana
    #     spec:
    #       replicas: 1
    #       selector:
    #         matchLabels:
    #           app: oauth2-proxy-grafana
    #       template:
    #         metadata:
    #           labels:
    #             app: oauth2-proxy-grafana
    #         spec:
    #           nodeSelector:
    #             node-role.kubernetes.io/control-plane: ""
    #           tolerations:
    #           - key: node-role.kubernetes.io/control-plane
    #             operator: Exists
    #             effect: NoSchedule
    #           containers:
    #           - name: oauth2-proxy
    #             image: quay.io/oauth2-proxy/oauth2-proxy:v7.3.0
    #             args:
    #             - --provider=oidc
    #             - --oidc-issuer-url={{ keycloak_url | default(keycloak_admin_url) }}/auth/realms/{{ grafana_oauth_realm | default('cluster-services') }}
    #             - --client-id=$(CLIENT_ID)
    #             - --client-secret=$(CLIENT_SECRET)
    #             - --cookie-secret=$(COOKIE_SECRET)
    #             - --cookie-secure=false
    #             - --cookie-samesite=lax
    #             - --email-domain=*
    #             - --insecure-oidc-allow-unverified-email=true
    #             - --pass-user-headers=true
    #             - --pass-access-token=true
    #             - --set-xauthrequest=true
    #             - --redirect-url=http://{{ ansible_default_ipv4.address }}:30301/oauth2/callback
    #             - --http-address=0.0.0.0:4180
    #             - --upstream=http://grafana:3000/
    #             env:
    #             - name: CLIENT_ID
    #               valueFrom:
    #                 secretKeyRef:
    #                   name: oauth2-proxy-grafana
    #                   key: client-id
    #             - name: CLIENT_SECRET
    #               valueFrom:
    #                 secretKeyRef:
    #                   name: oauth2-proxy-grafana
    #                   key: client-secret
    #             - name: COOKIE_SECRET
    #               valueFrom:
    #                 secretKeyRef:
    #                   name: oauth2-proxy-grafana
    #                   key: cookie-secret
    #             ports:
    #             - containerPort: 4180
    #     ---
    #     apiVersion: v1
    #     kind: Service
    #     metadata:
    #       name: oauth2-proxy-grafana
    #       labels:
    #         app: oauth2-proxy-grafana
    #     spec:
    #       type: NodePort
    #       ports:
    #       - port: 4180
    #         targetPort: 4180
    #         nodePort: 30301
    #         name: http
    #       selector:
    #         app: oauth2-proxy-grafana
    #     EOF
    #   register: oauth2_apply
    #   changed_when: "oauth2_apply.rc == 0"

    - name: "Configure Grafana with native Keycloak OAuth integration"
      become: true
      become_user: root
      ansible.builtin.command:
        cmd: >
          kubectl --kubeconfig={{ kubeconfig }} -n monitoring set env deployment/grafana
          GF_AUTH_ANONYMOUS_ENABLED=false
          GF_AUTH_GENERIC_OAUTH_ENABLED=true
          GF_AUTH_GENERIC_OAUTH_NAME=Keycloak
          GF_AUTH_GENERIC_OAUTH_ALLOW_SIGN_UP=true
          GF_AUTH_GENERIC_OAUTH_CLIENT_ID=grafana
          GF_AUTH_GENERIC_OAUTH_SCOPES='openid profile email'
          GF_AUTH_GENERIC_OAUTH_AUTH_URL='{{ keycloak_url }}/auth/realms/cluster-services/protocol/openid-connect/auth'
          GF_AUTH_GENERIC_OAUTH_TOKEN_URL='{{ keycloak_url }}/auth/realms/cluster-services/protocol/openid-connect/token'
          GF_AUTH_GENERIC_OAUTH_API_URL='{{ keycloak_url }}/auth/realms/cluster-services/protocol/openid-connect/userinfo'
          GF_AUTH_GENERIC_OAUTH_ROLE_ATTRIBUTE_PATH="contains(groups[*], 'grafana-admin') && 'Admin' || 'Viewer'"
          GF_USERS_AUTO_ASSIGN_ORG=true
          GF_USERS_AUTO_ASSIGN_ORG_ROLE=Admin
      register: grafana_oauth_env_set
      changed_when: true
    
    - name: "Set Grafana OAuth client secret from Kubernetes secret"
      become: true
      become_user: root
      ansible.builtin.shell:
        cmd: |
          CLIENT_SECRET=$(kubectl --kubeconfig={{ kubeconfig }} -n monitoring get secret grafana-oidc-secret -o jsonpath='{.data.client-secret}' | base64 -d)
          kubectl --kubeconfig={{ kubeconfig }} -n monitoring set env deployment/grafana GF_AUTH_GENERIC_OAUTH_CLIENT_SECRET="$CLIENT_SECRET"
      register: grafana_secret_set
      changed_when: true

    - name: "Expose Grafana Service as NodePort on port 30300"
      become: true
      become_user: root
      ansible.builtin.shell: |
        set -e
        cat <<'EOF' | kubectl --kubeconfig={{ kubeconfig }} -n monitoring apply -f -
        apiVersion: v1
        kind: Service
        metadata:
          name: grafana
          namespace: monitoring
          labels:
            app: grafana
            app.kubernetes.io/name: grafana
        spec:
          type: NodePort
          ports:
          - port: 3000
            targetPort: 3000
            nodePort: 30300
            name: web
          selector:
            app: grafana
            app.kubernetes.io/name: grafana
        EOF
      register: grafana_service_update
      changed_when: "grafana_service_update.rc == 0"

    - name: "Restart grafana to pick up OAuth changes"
      become: true
      become_user: root
      ansible.builtin.command:
        cmd: kubectl --kubeconfig={{ kubeconfig }} -n monitoring rollout restart deployment/grafana
      register: grafana_restart_oauth
      changed_when: true

    # =============================================================================
    # Wait for Core Components
    # =============================================================================
    
    - name: "Wait for Prometheus to be ready (180s)"
      ansible.builtin.command:
        cmd: >
          kubectl --kubeconfig={{ kubeconfig }} wait --for=condition=ready pod
          -l app.kubernetes.io/name=prometheus -n monitoring --timeout=180s
      register: prometheus_ready
      changed_when: false
      failed_when: false

    - name: "Wait for Loki to be ready (180s)"
      ansible.builtin.command:
        cmd: >
          kubectl --kubeconfig={{ kubeconfig }} wait --for=condition=ready pod
          -l app.kubernetes.io/name=loki -n monitoring --timeout=180s
      register: loki_ready
      changed_when: false
      failed_when: false

    - name: "Wait for Grafana to be ready (60s)"
      ansible.builtin.command:
        cmd: >
          kubectl --kubeconfig={{ kubeconfig }} wait --for=condition=ready pod
          -l app=grafana -n monitoring --timeout=60s
      register: grafana_ready
      changed_when: false
      failed_when: false

    # =============================================================================
    # Verification
    # =============================================================================
    
    - name: "Get all monitoring pods"
      ansible.builtin.command:
        cmd: kubectl --kubeconfig={{ kubeconfig }} get pods -n monitoring -o wide
      register: monitoring_pods
      changed_when: false

    - name: "Display monitoring pods"
      ansible.builtin.debug:
        msg: "{{ monitoring_pods.stdout_lines }}"

    - name: "Get all monitoring services"
      ansible.builtin.command:
        cmd: kubectl --kubeconfig={{ kubeconfig }} get svc -n monitoring
      register: monitoring_services
      changed_when: false

    - name: "Display monitoring services"
      ansible.builtin.debug:
        msg: "{{ monitoring_services.stdout_lines }}"

    # =============================================================================
    # Health Checks
    # =============================================================================
    
    - name: "Check Prometheus health"
      ansible.builtin.uri:
        url: "http://127.0.0.1:30090/-/healthy"
        method: GET
        status_code: 200
      register: prometheus_health
      failed_when: false
      changed_when: false

    - name: "Display Prometheus health status"
      ansible.builtin.debug:
        msg: "Prometheus health: {{ 'OK' if prometheus_health.status == 200 else 'FAILED' }}"

    - name: "Check Grafana health"
      ansible.builtin.uri:
        url: "http://127.0.0.1:30300/api/health"
        method: GET
        status_code: 200
      register: grafana_health
      failed_when: false
      changed_when: false

    - name: "Display Grafana health status"
      ansible.builtin.debug:
        msg: "Grafana health: {{ 'OK' if grafana_health.status == 200 else 'FAILED' }}"

    # =============================================================================
    # Summary
    # =============================================================================
    
    - name: "Display deployment summary"
      ansible.builtin.debug:
        msg: |
          ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
          Monitoring Stack Deployment Complete
          ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
          
          ✅ Prometheus: http://{{ ansible_default_ipv4.address }}:30090
          ✅ Grafana: http://{{ ansible_default_ipv4.address }}:30300
          ✅ Loki: http://{{ ansible_default_ipv4.address }}:31100
          
          Credentials:
          - Grafana: admin/admin (anonymous access enabled)
          
          Verification:
          kubectl get pods -n monitoring
          kubectl get svc -n monitoring
          ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
